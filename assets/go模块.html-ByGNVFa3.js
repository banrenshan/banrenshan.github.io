import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as t,a as o}from"./app-Crw0g0C7.js";const d={},i=o(`<h1 id="go-模块化的历史" tabindex="-1"><a class="header-anchor" href="#go-模块化的历史"><span>GO 模块化的历史</span></a></h1><p>在Go 1.11版本之前，几乎所有的包管理工具都绕不开<code>GOPATH</code>这个环境变量。其主要用来放置项目依赖包的源代码。</p><p><code>GOPATH</code>不区分项目，代码中任何import的路径均从GOPATH根目录开始；当有多个项目时，不同项目对于依赖库的版本需求不一致时，无法在一个GOPATH下面放置不同版本的依赖项。</p><p>典型的例子：当有多项目时候，A项目依赖C 1.0.0，B项目依赖C 2.0.0，由于没有依赖项版本的概念，C 1.0.0和C 2.0.0无法同时在GOPATH下共存，解决办法是分别为A项目和B项目设置GOPATH，将不同版本的C源代码放在两个GOPATH中，彼此独立（编译时切换），或者C 1.0.0和C 2.0.0两个版本更改包名。无论哪种解决方法，都需要人工判断更正，不具备便利性。</p><p>此外，在Go Modules之前，没有任何语义化的数据可以知道当前项目的所有依赖项，需要手动找出所有依赖。对项目而言，需要将所有的依赖项全部放入源代码控制中。如果剔除某个依赖，需要在源代码中手工确认某个依赖是否剔除。</p><p>为了解决GOPATH的缺陷，Go官方和社区推出许多解决方案，比如godep、govendor、glide等，这些工具要么未彻底解决GOPATH存在的问题要么使用起来繁冗，这才催生了Go Modules的出现。</p><h1 id="模块管理" tabindex="-1"><a class="header-anchor" href="#模块管理"><span>模块管理</span></a></h1><h2 id="创建模块" tabindex="-1"><a class="header-anchor" href="#创建模块"><span>创建模块</span></a></h2><p>在你的模块根目录下执行命令：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>go mod init github.com/robteix/testmod
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>github.com/robteix/testmod 是github 仓库的目录，你也可以指定别的地址。</p></blockquote><p>该命令会在目录下生成go.mod文件，内容如下：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>module github.com/robteix/testmod

go <span class="token number">1.13</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="下载模块" tabindex="-1"><a class="header-anchor" href="#下载模块"><span>下载模块</span></a></h2><p>在将代码推送至Github之后，其他人可以使用如下命令下载到<code>testmod</code>:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>go get github.com/robteix/testmod
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认情况下，<code>go get</code>将会下载master分支。上面我们说过，Go Modules具有语义化版本管理功能的，所以可以使用<code>go get</code>下载特定版本的包：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>go get github.com/robteix/testmod@vX.X.X <span class="token comment">#下载模块并将依赖信息添加到go.mod文件</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>Go在查找包版本时使用git仓库的tags功能</p></blockquote><h2 id="更新模块" tabindex="-1"><a class="header-anchor" href="#更新模块"><span>更新模块</span></a></h2><p>默认情况下，出于构建中的可预测性和稳定性考虑，Go不会自动更新模块，需要手动更新依赖。可以使用如下方式更新依赖包：</p><ol><li>使用<code>go get -u</code>，更新到修订版本或次要版本，即从v1.0.0更新到v1.0.1，如果v1.1.0可用，则更新到v1.1.0</li><li>使用<code>go get -u=path</code>，更新到修订版本，即从v1.0.0更新到v1.0.1。</li><li>使用<code>go get package-path@vX.X.X</code>更新到特定版本。</li></ol><p>使用上述任一方式更新之后，go.mod中的依赖记录都会被更新。</p><h2 id="依赖本地包" tabindex="-1"><a class="header-anchor" href="#依赖本地包"><span>依赖本地包</span></a></h2><p>有一种可能出现的情况：项目的某个依赖包并不在Github或者其他代码托管网站上，而是在本地，此时需要修改<code>go.mod</code>文件引入本地依赖包。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>require (
    3rd/module/testmod v0.0.0
)

replace 3rd/module/testmod =&gt; /usr/local/go/testmod
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码中以<code>3rd/module/testmod</code>作为导入路径，编译时会根据<code>replace</code>找到真实代码目录。</p><h2 id="无网络构建" tabindex="-1"><a class="header-anchor" href="#无网络构建"><span>无网络构建</span></a></h2><p>有一种现实情况是：内部构建系统是无网络环境的，也就是说所有的依赖项都需要纳入内部版本控制中，Go Modules提供了此功能：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>go mod vendor
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该命令会将在当前项目根目录下创建vendor目录，然后将项目所有依赖项缓存此目录中。在默认情况下go build将忽略vendor目录，如果要从vendor目录开始构建：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>go build -mod vendor
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="依赖管理" tabindex="-1"><a class="header-anchor" href="#依赖管理"><span>依赖管理</span></a></h2><p>列出了当前模块所有的依赖项:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>go list <span class="token parameter variable">-m</span> all 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>移除模块中没有用到的依赖项:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>go mod tidy 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="go-install" tabindex="-1"><a class="header-anchor" href="#go-install"><span>go install</span></a></h2><p><code>go install</code> 和 <code>go get</code> 都是 Go 语言的工具命令，但它们之间有一些区别。</p><ul><li><code>go get</code>：用于从远程代码存储库（如 GitHub）中下载或更新 Go 代码包。它会下载代码包并将其存储在 <code>$GOPATH/src</code> 目录下对应的位置，并编译代码包中的程序和库。如果目标包之前已经被下载过了，那么 <code>go get</code> 会尝试更新到最新版本，并重新编译程序和库文件。在更新完代码包后，<code>go get</code> 还会自动把下载的代码包的可执行文件复制到 <code>$GOPATH/bin</code> 目录下，以方便直接使用该可执行文件。</li><li><code>go install</code>：用于编译并安装 Go 代码包，并将其生成的可执行程序或库文件存储到 <code>$GOPATH/bin</code> 或者 <code>$GOPATH/pkg</code> 目录下。如果你在项目目录下执行 <code>go install</code>，它将会编译并安装当前项目的代码，生成可执行文件并将其保存到 <code>$GOPATH/bin</code> 目录下（如果项目是一个库，则生成的是 <code>.a</code> 文件，并将其存储到 <code>$GOPATH/pkg</code> 目录下）。</li></ul><p>因此，<code>go get</code> 用于下载和更新代码包，并产生对应的可执行程序，而 <code>go install</code> 用于将一个 Go 代码包转化为可执行程序或库文件，并安装到系统路径以供直接使用。</p>`,41),n=[i];function s(l,c){return a(),t("div",null,n)}const g=e(d,[["render",s],["__file","go模块.html.vue"]]),h=JSON.parse('{"path":"/Go/go%E6%A8%A1%E5%9D%97.html","title":"Go 模块","lang":"zh-CN","frontmatter":{"title":"Go 模块","date":"2024-04-24T00:00:00.000Z","tags":["Go"],"categories":["Go"],"description":"GO 模块化的历史 在Go 1.11版本之前，几乎所有的包管理工具都绕不开GOPATH这个环境变量。其主要用来放置项目依赖包的源代码。 GOPATH不区分项目，代码中任何import的路径均从GOPATH根目录开始；当有多个项目时，不同项目对于依赖库的版本需求不一致时，无法在一个GOPATH下面放置不同版本的依赖项。 典型的例子：当有多项目时候，A项目...","head":[["meta",{"property":"og:url","content":"https://banrenshan.github.io/Go/go%E6%A8%A1%E5%9D%97.html"}],["meta",{"property":"og:site_name","content":"心之所向，素履以往"}],["meta",{"property":"og:title","content":"Go 模块"}],["meta",{"property":"og:description","content":"GO 模块化的历史 在Go 1.11版本之前，几乎所有的包管理工具都绕不开GOPATH这个环境变量。其主要用来放置项目依赖包的源代码。 GOPATH不区分项目，代码中任何import的路径均从GOPATH根目录开始；当有多个项目时，不同项目对于依赖库的版本需求不一致时，无法在一个GOPATH下面放置不同版本的依赖项。 典型的例子：当有多项目时候，A项目..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-24T08:19:31.000Z"}],["meta",{"property":"article:author","content":"banrenshan"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:published_time","content":"2024-04-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-24T08:19:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go 模块\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-24T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-24T08:19:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"banrenshan\\",\\"url\\":\\"https://github.com/banrenshan\\"}]}"]]},"headers":[{"level":2,"title":"创建模块","slug":"创建模块","link":"#创建模块","children":[]},{"level":2,"title":"下载模块","slug":"下载模块","link":"#下载模块","children":[]},{"level":2,"title":"更新模块","slug":"更新模块","link":"#更新模块","children":[]},{"level":2,"title":"依赖本地包","slug":"依赖本地包","link":"#依赖本地包","children":[]},{"level":2,"title":"无网络构建","slug":"无网络构建","link":"#无网络构建","children":[]},{"level":2,"title":"依赖管理","slug":"依赖管理","link":"#依赖管理","children":[]},{"level":2,"title":"go install","slug":"go-install","link":"#go-install","children":[]}],"git":{"createdTime":1713946771000,"updatedTime":1713946771000,"contributors":[{"name":"banrenshan","email":"CP_zhaozhiqiang@163.com","commits":1}]},"readingTime":{"minutes":4.5,"words":1351},"filePathRelative":"Go/go模块.md","localizedDate":"2024年4月24日","excerpt":"\\n<p>在Go 1.11版本之前，几乎所有的包管理工具都绕不开<code>GOPATH</code>这个环境变量。其主要用来放置项目依赖包的源代码。</p>\\n<p><code>GOPATH</code>不区分项目，代码中任何import的路径均从GOPATH根目录开始；当有多个项目时，不同项目对于依赖库的版本需求不一致时，无法在一个GOPATH下面放置不同版本的依赖项。</p>\\n<p>典型的例子：当有多项目时候，A项目依赖C 1.0.0，B项目依赖C 2.0.0，由于没有依赖项版本的概念，C 1.0.0和C 2.0.0无法同时在GOPATH下共存，解决办法是分别为A项目和B项目设置GOPATH，将不同版本的C源代码放在两个GOPATH中，彼此独立（编译时切换），或者C 1.0.0和C 2.0.0两个版本更改包名。无论哪种解决方法，都需要人工判断更正，不具备便利性。</p>","autoDesc":true}');export{g as comp,h as data};
