import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,a as n}from"./app-JRZgQj53.js";const t={},o=n(`<h1 id="资源" tabindex="-1"><a class="header-anchor" href="#资源"><span>资源</span></a></h1><p>仅仅使用 JAVA 的 <code>java.net.URL</code> 和针对不同 URL 前缀的标准处理器，并不能满足我们对各种底 层资源的访问，比如：我们就不能通过 URL 的标准实现来访问类路径或者相对 <code>ServletContext</code> 的各种资源。虽然我们可以针对特定的 URL 前缀来注册一个新的<code>URLStreamHandler</code>（和现有的针对各种特定前缀的处理器类似，比如 <code>http：</code>），然而这往往会是 一件比较麻烦的事情(要求了解 url 的实现机制等），而且 url 接口也缺少了部分基本的方法，如 检查当前资源是否存在的方法。</p><h2 id="resource-接口" tabindex="-1"><a class="header-anchor" href="#resource-接口"><span>Resource 接口</span></a></h2><p>相对标准 url 访问机制，spring 的 Resource 接口对抽象底层资源的访问提供了一套更好的机制。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Resource</span> <span class="token keyword">extends</span> <span class="token class-name">InputStreamSource</span> <span class="token punctuation">{</span>

    <span class="token keyword">boolean</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">URL</span> <span class="token function">getURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>

    <span class="token class-name">File</span> <span class="token function">getFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>

    <span class="token class-name">Resource</span> <span class="token function">createRelative</span><span class="token punctuation">(</span><span class="token class-name">String</span> relativePath<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>

    <span class="token class-name">String</span> <span class="token function">getFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InputStreamSource</span> <span class="token punctuation">{</span>

    <span class="token class-name">InputStream</span> <span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>getInputStream()</code>: 定位并且打开当前资源，返回当前资源的 <code>InputStream</code>。每一次 调用都会返回一个新的 <code>InputStream</code>，因此关闭当前输出流就成为了调用者的责任。</li><li><code>exists()</code>: 返回一个<code> boolean</code>，表示当前资源是否真的存在。</li><li><code>isOpen()</code>: 返回一个 boolean，表示当前资源是否已打开的输入流。如果结果为 true， 返回的 <code>InputStream</code> 不能多次读取，只能是一次性读取之后，就关闭 <code>InputStream</code>，以防 止内存泄漏。除了 <code>InputStreamResource</code>，其他常用 Resource 实现都会返回 false。</li><li><code>getDescription()</code>: 返回当前资源的描述，当处理资源出错时，资源的描述会用于错误信息的 输出。一般来说，资源的描述是一个完全限定的文件名称，或者是当前资源的真实 url。</li></ul><p>Resource 接口里的其他方法可以让你获得代表当前资源的 URL 或 File 对象（前提是底层实现可 兼容的，也支持该功能）。</p><p>Resource抽象在Spring本身被广泛使用，作为许多方法签名中的参数类型。 某些 Spring API中的方法（例如各种<code>ApplicationContext</code>实现的构造函数）接受一个以特定前缀形式或简单的形式String参数，用于创建适用于该上下文实现的资源。</p><blockquote><p><strong>Resource 接口（实现）不仅可以被 spring 大量的应用，其也非常适合在你编程过程中作为访问资源的辅助工具类</strong>。需要注意的是 Resource 实现并没有去重新发明轮子，而是尽可能地采用封装。举个例子， UrlResource 里就封装了一个 URL 对象，在其内的逻辑就是通过封装的 URL 对象来完成的。</p></blockquote><h2 id="内置的resource实现" tabindex="-1"><a class="header-anchor" href="#内置的resource实现"><span>内置的Resource实现</span></a></h2><h3 id="urlresource" tabindex="-1"><a class="header-anchor" href="#urlresource"><span>UrlResource</span></a></h3><p><code>UrlResource </code>封装了一个 <code>java.net.URL</code> 对象，用来访问 URL 类型的对象，比如 本地文件、 HTTP 、 FTP等。所有的 URL 都可以用一个标准化的字符串来 表示。例如：用于访问文件系统路径 的<code>file:</code>,通过 http 协议访问资源的 <code>http:</code>,通过 ftp 协议访问资源的 <code>ftp:</code> 。</p><p>可以显式化地使用 <code>UrlResource </code>构造函数来创建一个 <code>UrlResource</code>，不过通常我们可以在调用一 个 api 方法是，使用一个代表路径的 String 参数来隐式创建一个 <code>UrlResource</code>。对于后一种情 况，会由一个 javabean <code>PropertyEditor </code>来决定创建哪一种 Resource。如果路径里包含某一个 通用的前缀（如 classpath:),<code>PropertyEditor </code>会根据这个通用的前缀来创建恰当的 <code>Resource</code>；反之，<strong>如果 <code>PropertyEditor </code>无法识别这个前缀，会把这个路径作为一个标准的 URL 来创建一个 <code>UrlResource</code></strong>。</p><h3 id="classpathresource" tabindex="-1"><a class="header-anchor" href="#classpathresource"><span>ClassPathResource</span></a></h3><p><code>ClassPathResource </code>可以从类<mark>路径</mark>上加载资源，<strong>其可以使用线程上下文加载器、指定加载器或指定 的 class 类型中的任意一个来加载资源</strong>。</p><p>当类路径上资源存于文件系统中，ClassPathResource 支持以 java.io.File 的形式访问，当 类路径上的资源存于尚未解压(没有 被Servlet 引擎或其他可解压的环境解压）的 jar 包中， ClassPathResource 就不再支持以 java.io.File 的形式访问。鉴于上面所说这个问题， spring 中各式 Resource 实现都支持以 jave.net.URL 的形式访问。</p><p>可以显式使用 <code>ClassPathResource </code>构造函数来创建一个 <code>ClassPathResource </code>，不过通常我们 可以在调用一个 api 方法时，使用一个代表路径的 String 参数来隐式创建一个<code>ClassPathResource</code>。对于后一种情况，会由一个 javabean <code>PropertyEditor </code>来识别路径中<code>classpath:</code>前缀，从而创建一个 <code>ClassPathResource</code>。</p><h3 id="filesystemresource" tabindex="-1"><a class="header-anchor" href="#filesystemresource"><span>FileSystemResource</span></a></h3><p>这是针对 java.io.File 提供的 <code>Resource </code>实现。显然，我们可以使用 <code>FileSystemResource </code>的 getFile() 函数获取 File 对象，使用 <code>getURL()</code> 获取 URL 对象。</p><h3 id="servletcontextresource" tabindex="-1"><a class="header-anchor" href="#servletcontextresource"><span>ServletContextResource</span></a></h3><p>这是为了获取 web 根路径的 ServletContext 资源而提供的 Resource 实现。</p><p><code>ServletContextResource </code>完全支持以流和 URL 的方式访问，可只有当 web 项目是已解压的(不 是以 war 等压缩包形式存在)且该 <code>ServletContext </code>资源存于文件系统里，<code>ServletContextResource </code>才支持以 java.io.File 的方式访问。至于说到，我们的 web 项目 是否已解压和相关的 <code>ServletContext </code>资源是否会存于文件系统里，这个取决于我们所使用的 Servlet 容器。若 Servlet 容器没有解压 web 项目，我们可以直接以 JAR 的形式的访问，或者 其他可以想到的方式（如访问数据库）等。</p><h3 id="inputstreamresource" tabindex="-1"><a class="header-anchor" href="#inputstreamresource"><span>InputStreamResource</span></a></h3><p>给定<code>InputStream</code>的资源实现。 只有在没有特定的资源实现适用的情况下才能使用。 特别是，如果可能的话，首选<code>ByteArrayResource</code>或任何基于文件的资源实现。</p><p>与其他Resource实现相比，这是已打开资源的描述符 - 因此从isOpen（）返回true。 如果您需要将资源描述符保存在某处，或者您需要多次读取流，请不要使用它。</p><h3 id="bytearrayresource" tabindex="-1"><a class="header-anchor" href="#bytearrayresource"><span>ByteArrayResource</span></a></h3><p>这是给定字节数组的一个资源实现。 它为给定的字节数组创建一个<code>ByteArrayInputStream</code>。</p><p>从任何给定的字节数组中加载内容是很有用的，而不必求助于一次性的<code>InputStreamResource</code>。</p><h2 id="resourceloader" tabindex="-1"><a class="header-anchor" href="#resourceloader"><span>ResourceLoader</span></a></h2><p>实现ResourceLoader接口可以获取资源实例对象的引用。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ResourceLoader</span> <span class="token punctuation">{</span>

    <span class="token class-name">Resource</span> <span class="token function">getResource</span><span class="token punctuation">(</span><span class="token class-name">String</span> location<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所有的应用程序上下文都实现了<code>ResourceLoader</code>接口，因此所有的应用程序上下文都可以用来获取<code>Resource</code>实例。 当您在特定的应用程序上下文中调用<code>getResource</code>，并且指定的位置路径没有特定的前缀时，您将返回适合该特定应用程序上下文的资源类型。 例如，假设以下代码片段针对<code>ClassPathXmlApplicationContext</code>实例执行：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Resource</span> template <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">&quot;some/resource/path/myTemplate.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>返回将是一个<code>ClassPathResource</code>; 如果对<code>FileSystemXmlApplicationContext</code>实例执行相同的方法，则会返回<code>FileSystemResource</code>。 对于<code>WebApplicationContext</code>，您将返回一个<code>ServletContextResource</code>，等等。</p><p>因此，您可以以适合特定应用程序上下文的方式加载资源。</p><p>另一方面，通过指定特殊的<code>classpath:</code>前缀来强制使用<code>ClassPathResource</code>，而不管应用程序上下文类型如何。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Resource</span> template <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">&quot;classpath:some/resource/path/myTemplate.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>同样，可以通过指定任何标准的java.net.URL前缀来强制使用UrlResource：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Resource</span> template <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">&quot;file:///some/resource/path/myTemplate.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Resource</span> template <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">&quot;http://myhost.com/resource/path/myTemplate.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下表总结了将字符串转换为资源的策略：</p><table><thead><tr><th>Prefix</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>classpath:</td><td>classpath:com/myapp/config.xml</td><td>从类路径加载。</td></tr><tr><td>file:</td><td>[file:///data/config.xml](file:///data/config.xml)</td><td>从文件系统加载为URL。</td></tr><tr><td>http:</td><td>http://myserver/logo.png</td><td>加载为网址。</td></tr><tr><td>(none)</td><td>/data/config.xml</td><td>取决于底层的ApplicationContext。</td></tr></tbody></table><h2 id="resourceloaderaware接口" tabindex="-1"><a class="header-anchor" href="#resourceloaderaware接口"><span>ResourceLoaderAware接口</span></a></h2><p>ResourceLoaderAware接口是一个特殊的标记接口，用于标识期望通过ResourceLoader引用提供的对象。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ResourceLoaderAware</span> <span class="token punctuation">{</span>

    <span class="token keyword">void</span> <span class="token function">setResourceLoader</span><span class="token punctuation">(</span><span class="token class-name">ResourceLoader</span> resourceLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当一个类实现了<code>ResourceLoaderAware</code>并且被部署到一个应用上下文中时（作为一个Spring管理的bean），它被应用上下文识别为<code>ResourceLoaderAware</code>。然后，应用程序上下文将调用<code>setResourceLoader（ResourceLoader）</code>，将自身作为参数提供（<strong>请记住，Spring中的所有应用程序上下文实现ResourceLoader接口</strong>）。</p><p>当然，由于<code>ApplicationContext</code>是一个<code>ResourceLoader</code>，bean也可以实现<code>ApplicationContextAware</code>接口并直接使用提供的应用程序上下文来加载资源，但通常情况下，最好使用专用的<code>ResourceLoader</code>接口（如果需要的话）。 该代码只会耦合到资源加载接口，该接口可以被认为是一个实用接口，而不是整个<code>Spring ApplicationContext</code>接口。</p><p>从Spring 2.5开始，可以依靠<code>ResourceLoader</code>的自动装配来替代实现<code>ResourceLoaderAware</code>接口。“传统”构造函数和byType自动装配模式（如自动装配协作者中所述）现在可以分别为构造函数参数或setter方法参数提供<code>ResourceLoader</code>类型的依赖关系。 为了获得更大的灵活性（包括自动装配字段和多个参数方法的能力），请考虑使用新的基于注释的自动装配功能。在这种情况下，只要字段，构造函数或方法携带<code>@Autowired</code>注释，<code>ResourceLoader</code>就会自动装入。</p><h3 id="resources-as-dependencies" tabindex="-1"><a class="header-anchor" href="#resources-as-dependencies"><span>Resources as dependencies</span></a></h3><p>如果bean本身要通过某种动态过程来确定和提供资源路径，那么bean可能使用<code>ResourceLoader</code>接口来加载资源。 考虑加载某种模板的例子，其中需要的特定资源取决于用户的角色。 所有应用程序上下文都注册并使用一个特殊的JavaBeans <code>PropertyEditor</code>，它可以将String路径转换为Resource对象。因此，如果myBean具有Resource类型的模板属性，则可以使用该资源的简单字符串进行配置，如下所示：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">&quot;myBean&quot;</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;...&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">&quot;template&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;some/resource/path/myTemplate.txt&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，资源路径没有前缀，因此应用上下文本身将用作<code>ResourceLoader</code>，资源本身将根据上下文的确切类型通过<code>ClassPathResource</code>，<code>FileSystemResource</code>或<code>ServletContextResource</code>（根据需要）加载。</p><p>如果需要强制使用特定的资源类型，则可以使用前缀。 以下两个示例显示如何强制<code>ClassPathResource</code>和<code>UrlResource</code>（后者用于访问文件系统文件）。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">&quot;template&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;classpath:some/resource/path/myTemplate.txt&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">&quot;template&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;file:///some/resource/path/myTemplate.txt&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="application-contexts和resource-paths" tabindex="-1"><a class="header-anchor" href="#application-contexts和resource-paths"><span>Application contexts和Resource paths</span></a></h2><h3 id="构建应用程序上下文" tabindex="-1"><a class="header-anchor" href="#构建应用程序上下文"><span>构建应用程序上下文</span></a></h3><p>应用程序上下文构造函数（针对特定应用程序上下文类型）通常需要一个字符串或字符串数组作为资源的位置路径，以构成上下文定义的XML文件。</p><p>当这样的位置路径没有前缀时，从该路径构建并用于加载bean定义的特定资源类型取决当前所使用的应用程序上下文。 例如，如果您按照以下方式创建<code>ClassPathXmlApplicationContext</code>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;conf/appContext.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于将使用<code>ClassPathResource</code>，因此将从类路径加载bean定义。 但是，如果您创建<code>FileSystemXmlApplicationContext</code>，如下所示：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span>
    <span class="token keyword">new</span> <span class="token class-name">FileSystemXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;conf/appContext.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>bean定义将从文件系统位置加载，在这种情况下，相对于当前工作目录。 请注意，在位置路径中使用特殊类路径前缀或标准URL前缀将覆盖为加载定义而创建的默认类型的资源。 所以这个<code>FileSystemXmlApplicationContext</code></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span>
    <span class="token keyword">new</span> <span class="token class-name">FileSystemXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;classpath:conf/appContext.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上会从类路径中加载它的bean定义。 但是，它仍然是一个<code>FileSystemXmlApplicationContext</code>。 如果随后将其用作<code>ResourceLoader</code>，则任何前缀不固定的路径仍将被视为文件系统路径。</p><h4 id="构造classpathxmlapplicationcontext实例-快捷方式" tabindex="-1"><a class="header-anchor" href="#构造classpathxmlapplicationcontext实例-快捷方式"><span>构造ClassPathXmlApplicationContext实例 - 快捷方式</span></a></h4><p><code>ClassPathXmlApplicationContext</code>公开了许多构造函数以实现方便的实例化。 其基本思想是只提供一个字符串数组，它只包含XML文件本身的文件名（没有前导路径信息），另一个是提供一个Class; <code>ClassPathXmlApplicationContext</code>将从提供的类中派生路径信息。</p><p>有一个例子希望能够说清楚：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>com/
  foo/
    services.xml
    daos.xml
    MessengerService.class
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由<code>services.xml</code>和<code>daos.xml</code>中定义的bean组成的<code>ClassPathXmlApplicationContext</code>实例可以像这样被实例化:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">&quot;services.xml&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;daos.xml&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token class-name">MessengerService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="应用程序上下文构造器资源路径中的通配符" tabindex="-1"><a class="header-anchor" href="#应用程序上下文构造器资源路径中的通配符"><span>应用程序上下文构造器资源路径中的通配符</span></a></h3><p>应用程序上下文构造函数值中的资源路径：</p><ul><li>可能是一个简单的路径，它具有到目标资源的一对一映射，</li><li>或者可以包含特殊的<code>classpath *：</code>前缀或Ant-样式正则表达式（使用Spring的PathMatcher进行匹配）</li></ul><h4 id="ant-style风格" tabindex="-1"><a class="header-anchor" href="#ant-style风格"><span>Ant-style风格</span></a></h4><p>当路径位置包含Ant样式时，例如：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/WEB-INF/*-context.xml
com/mycompany/**/applicationContext.xml
file:C:/some/path/*-context.xml
classpath:com/mycompany/**/applicationContext.xml
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ant模式为最后一个非通配符段的路径生成一个资源，并从中获取一个URL。如果此URL不是<code>jar：URL</code>或特定于容器的变体（例如，WebLogic中的zip，WebSphere中的wsjar等），则从中获取<code>java.io.File</code>，并通过遍历文件系统来解析通配符。 在jar URL的情况下，解析器要么从中获取<code>java.net.JarURLConnection</code>，要么手动解析jar URL，然后遍历jar文件的内容来解析通配符。</p><h4 id="classpath-前缀" tabindex="-1"><a class="header-anchor" href="#classpath-前缀"><span><code>classpath*</code>前缀:</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span>
	<span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;classpath*:conf/appContext.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个特殊的前缀指定必须获得与给定名称匹配的所有类路径资源(在内部，这基本上是通过调用<code>ClassLoader.getResources</code>) 然后合并以形成最终的应用上下文定义。</p><p>您还可以将<code>classpath*：</code>前缀与位置路径的其余部分中的<code>PathMatcher</code>模式组合在一起（例如，<code>classpath*∶META-INF/*-beans.xml</code>）。在这种情况下，解析策略相当简单：在最后一个非通配符路径段上使用ClassLoader.getResources调用来获取类加载器层次结构中的所有匹配资源，然后在每个资源之外，将前面描述的相同PathMatcher解析策略用于通配符子路径。</p><blockquote><p>通配符类路径依赖于底层<code>ClassLoader</code>的<code>getResources</code>方法。由于现在大多数应用程序服务器都提供自己的<code>ClassLoader</code>实现，因此行为可能会有所不同，尤其是在处理jar文件时。检查<code>classpath*</code>是否有效的一个简单测试是使用<code>getClass().getClassLoader().getResources(&quot;&lt;someFileInsideTheJar&gt;&quot;)</code>从类路径上的jar中加载文件。请对具有相同名称但位于两个不同位置的文件进行此测试 — 例如，具有相同名称和路径但位于类路径上不同jar中的文件。如果返回不适当的结果，请查看应用程序服务器文档中可能影响<code>ClassLoader</code>行为的设置。</p></blockquote><h4 id="其他有关通配符的说明" tabindex="-1"><a class="header-anchor" href="#其他有关通配符的说明"><span>其他有关通配符的说明</span></a></h4><p>请注意，除非实际目标文件驻留在文件系统中，否则<code>classpath*:</code>与Ant样式模式结合使用时，只能在模式启动之前至少有一个根目录可靠地工作。这意味着<code>classpath*:*.xml</code>这样的模式可能不会从jar文件的根文件中检索文件，而只能从扩展目录的根文件中检索文件。</p><p>Spring检索类路径条目的能力来源于JDK的<code>ClassLoader.getResources</code>方法，该方法仅返回传入的空字符串的文件系统位置（指示要搜索的潜在根）。Spring会评估URLClassLoader运行时配置和jar文件中的“java.class.path”清单，但这并不保证会导致可移植行为。</p><p>使用classpath:和Ant样式模式：如果要在多个类路径位置中使用要搜索的根包，则无法保证资源能够找到匹配的资源。 这是因为资源如</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>com/mycompany/package1/service-context.xml
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可能只在一个位置，但是当一条路径如</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>classpath:com/mycompany/**/service-context.xml
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用于尝试解决它，解析器将处理由<code>getResource(&quot;com/mycompany&quot;)</code>;返回的（第一个）URL。如果此基础程序包节点存在于多个类加载程序位置中，则实际的最终资源可能不在其下。因此，最好在这种情况下使用具有相同Ant样式的<code>classpath *：</code>，它将搜索包含根包的所有类路径位置。</p><h3 id="filesystemresource附加说明" tabindex="-1"><a class="header-anchor" href="#filesystemresource附加说明"><span>FileSystemResource附加说明</span></a></h3><p>未附加到FileSystemApplicationContext（即FileSystemApplicationContext不是实际的ResourceLoader）的FileSystemResource将按照您的预期处理绝对路径和相对路径。 相对路径是相对于当前工作目录的，而绝对路径是相对于文件系统的根。</p><p>但是，为了向后兼容（历史）原因，当FileSystemApplicationContext是ResourceLoader时会发生变化。FileSystemApplicationContext只是强制所有附加的FileSystemResource实例将所有位置路径视为相对，无论它们是否以一个前导斜杠开始。 实际上，这意味着以下内容是等同的：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span>
    <span class="token keyword">new</span> <span class="token class-name">FileSystemXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;conf/context.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span>
    <span class="token keyword">new</span> <span class="token class-name">FileSystemXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;/conf/context.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如下所示：（尽管它们有所不同，但一种情况是相对的，另一种是绝对的）。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">FileSystemXmlApplicationContext</span> ctx <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
ctx<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">&quot;some/resource/path/myTemplate.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">FileSystemXmlApplicationContext</span> ctx <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
ctx<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">&quot;/some/resource/path/myTemplate.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实践中，如果需要真正的绝对文件系统路径，最好放弃使用FileSystemResource/FileSystemXmlApplicationContext的绝对路径，并通过使用<code>file:URL</code>前缀强制使用UrlResource。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// actual context type doesn&#39;t matter, the Resource will always be UrlResource</span>
ctx<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">&quot;file:///some/resource/path/myTemplate.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// force this FileSystemXmlApplicationContext to load its definition via a UrlResource</span>
<span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span>
    <span class="token keyword">new</span> <span class="token class-name">FileSystemXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;file:///conf/context.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,97),c=[o];function p(l,r){return a(),s("div",null,c)}const u=e(t,[["render",p],["__file","spring-resource.html.vue"]]),m=JSON.parse('{"path":"/Spring/spring-resource.html","title":"Spring 资源处理","lang":"zh-CN","frontmatter":{"title":"Spring 资源处理","date":"2024-04-27T00:00:00.000Z","categories":["Spring"],"tags":["Spring","resource"],"description":"资源 仅仅使用 JAVA 的 java.net.URL 和针对不同 URL 前缀的标准处理器，并不能满足我们对各种底 层资源的访问，比如：我们就不能通过 URL 的标准实现来访问类路径或者相对 ServletContext 的各种资源。虽然我们可以针对特定的 URL 前缀来注册一个新的URLStreamHandler（和现有的针对各种特定前缀的处理器类...","head":[["meta",{"property":"og:url","content":"https://banrenshan.github.io/Spring/spring-resource.html"}],["meta",{"property":"og:site_name","content":"心之所向，素履以往"}],["meta",{"property":"og:title","content":"Spring 资源处理"}],["meta",{"property":"og:description","content":"资源 仅仅使用 JAVA 的 java.net.URL 和针对不同 URL 前缀的标准处理器，并不能满足我们对各种底 层资源的访问，比如：我们就不能通过 URL 的标准实现来访问类路径或者相对 ServletContext 的各种资源。虽然我们可以针对特定的 URL 前缀来注册一个新的URLStreamHandler（和现有的针对各种特定前缀的处理器类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-01T09:42:13.000Z"}],["meta",{"property":"article:author","content":"banrenshan"}],["meta",{"property":"article:tag","content":"Spring"}],["meta",{"property":"article:tag","content":"resource"}],["meta",{"property":"article:published_time","content":"2024-04-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-01T09:42:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring 资源处理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-01T09:42:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"banrenshan\\",\\"url\\":\\"https://github.com/banrenshan\\"}]}"]]},"headers":[{"level":2,"title":"Resource 接口","slug":"resource-接口","link":"#resource-接口","children":[]},{"level":2,"title":"内置的Resource实现","slug":"内置的resource实现","link":"#内置的resource实现","children":[{"level":3,"title":"UrlResource","slug":"urlresource","link":"#urlresource","children":[]},{"level":3,"title":"ClassPathResource","slug":"classpathresource","link":"#classpathresource","children":[]},{"level":3,"title":"FileSystemResource","slug":"filesystemresource","link":"#filesystemresource","children":[]},{"level":3,"title":"ServletContextResource","slug":"servletcontextresource","link":"#servletcontextresource","children":[]},{"level":3,"title":"InputStreamResource","slug":"inputstreamresource","link":"#inputstreamresource","children":[]},{"level":3,"title":"ByteArrayResource","slug":"bytearrayresource","link":"#bytearrayresource","children":[]}]},{"level":2,"title":"ResourceLoader","slug":"resourceloader","link":"#resourceloader","children":[]},{"level":2,"title":"ResourceLoaderAware接口","slug":"resourceloaderaware接口","link":"#resourceloaderaware接口","children":[{"level":3,"title":"Resources as dependencies","slug":"resources-as-dependencies","link":"#resources-as-dependencies","children":[]}]},{"level":2,"title":"Application contexts和Resource paths","slug":"application-contexts和resource-paths","link":"#application-contexts和resource-paths","children":[{"level":3,"title":"构建应用程序上下文","slug":"构建应用程序上下文","link":"#构建应用程序上下文","children":[]},{"level":3,"title":"应用程序上下文构造器资源路径中的通配符","slug":"应用程序上下文构造器资源路径中的通配符","link":"#应用程序上下文构造器资源路径中的通配符","children":[]},{"level":3,"title":"FileSystemResource附加说明","slug":"filesystemresource附加说明","link":"#filesystemresource附加说明","children":[]}]}],"git":{"createdTime":1714556533000,"updatedTime":1714556533000,"contributors":[{"name":"banrenshan","email":"CP_zhaozhiqiang@163.com","commits":1}]},"readingTime":{"minutes":14.08,"words":4224},"filePathRelative":"Spring/spring-resource.md","localizedDate":"2024年4月27日","excerpt":"\\n<p>仅仅使用 JAVA 的 <code>java.net.URL</code> 和针对不同 URL 前缀的标准处理器，并不能满足我们对各种底 层资源的访问，比如：我们就不能通过 URL 的标准实现来访问类路径或者相对 <code>ServletContext</code> 的各种资源。虽然我们可以针对特定的 URL 前缀来注册一个新的<code>URLStreamHandler</code>（和现有的针对各种特定前缀的处理器类似，比如 <code>http：</code>），然而这往往会是 一件比较麻烦的事情(要求了解 url 的实现机制等），而且 url 接口也缺少了部分基本的方法，如 检查当前资源是否存在的方法。</p>","autoDesc":true}');export{u as comp,m as data};
